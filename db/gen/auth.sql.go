// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: auth.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addRefreshTokenQuery = `-- name: AddRefreshTokenQuery :one
UPDATE user_account
SET
  refresh_token = $1,
  updated_at = NOW()
WHERE
  ghUsername = $2
  AND status = true
RETURNING
  email,
  ghUsername,
  refresh_token,
  bounty
`

type AddRefreshTokenQueryParams struct {
	RefreshToken pgtype.Text `json:"refresh_token"`
	Ghusername   pgtype.Text `json:"ghusername"`
}

type AddRefreshTokenQueryRow struct {
	Email        string      `json:"email"`
	Ghusername   pgtype.Text `json:"ghusername"`
	RefreshToken pgtype.Text `json:"refresh_token"`
	Bounty       int32       `json:"bounty"`
}

func (q *Queries) AddRefreshTokenQuery(ctx context.Context, db DBTX, arg AddRefreshTokenQueryParams) (AddRefreshTokenQueryRow, error) {
	row := db.QueryRow(ctx, addRefreshTokenQuery, arg.RefreshToken, arg.Ghusername)
	var i AddRefreshTokenQueryRow
	err := row.Scan(
		&i.Email,
		&i.Ghusername,
		&i.RefreshToken,
		&i.Bounty,
	)
	return i, err
}

const beginUserRegistrationQuery = `-- name: BeginUserRegistrationQuery :one
INSERT INTO 
  user_onboarding
  (
    first_name,
    middle_name,
    last_name,
    email,
    ghUsername,
    otp,
    expiry_at
  )
VALUES ($1, $2, $3, $4, $5, $6, NOW() + INTERVAL '25 minutes')
RETURNING
  email, otp
`

type BeginUserRegistrationQueryParams struct {
	FirstName  string      `json:"first_name"`
	MiddleName pgtype.Text `json:"middle_name"`
	LastName   string      `json:"last_name"`
	Email      string      `json:"email"`
	Ghusername pgtype.Text `json:"ghusername"`
	Otp        string      `json:"otp"`
}

type BeginUserRegistrationQueryRow struct {
	Email string `json:"email"`
	Otp   string `json:"otp"`
}

func (q *Queries) BeginUserRegistrationQuery(ctx context.Context, db DBTX, arg BeginUserRegistrationQueryParams) (BeginUserRegistrationQueryRow, error) {
	row := db.QueryRow(ctx, beginUserRegistrationQuery,
		arg.FirstName,
		arg.MiddleName,
		arg.LastName,
		arg.Email,
		arg.Ghusername,
		arg.Otp,
	)
	var i BeginUserRegistrationQueryRow
	err := row.Scan(&i.Email, &i.Otp)
	return i, err
}

const checkForExistingOtpQuery = `-- name: CheckForExistingOtpQuery :one
SELECT
  email,
  otp
FROM
  user_onboarding 
WHERE
  ghUsername = $1
  AND expiry_at >= NOW()
`

type CheckForExistingOtpQueryRow struct {
	Email string `json:"email"`
	Otp   string `json:"otp"`
}

func (q *Queries) CheckForExistingOtpQuery(ctx context.Context, db DBTX, ghusername pgtype.Text) (CheckForExistingOtpQueryRow, error) {
	row := db.QueryRow(ctx, checkForExistingOtpQuery, ghusername)
	var i CheckForExistingOtpQueryRow
	err := row.Scan(&i.Email, &i.Otp)
	return i, err
}

const checkRefreshTokenQuery = `-- name: CheckRefreshTokenQuery :one
SELECT
  ghUsername, email
FROM
  user_account
WHERE
  refresh_token = $1
  AND email = $2
  AND status = true
`

type CheckRefreshTokenQueryParams struct {
	RefreshToken pgtype.Text `json:"refresh_token"`
	Email        string      `json:"email"`
}

type CheckRefreshTokenQueryRow struct {
	Ghusername pgtype.Text `json:"ghusername"`
	Email      string      `json:"email"`
}

func (q *Queries) CheckRefreshTokenQuery(ctx context.Context, db DBTX, arg CheckRefreshTokenQueryParams) (CheckRefreshTokenQueryRow, error) {
	row := db.QueryRow(ctx, checkRefreshTokenQuery, arg.RefreshToken, arg.Email)
	var i CheckRefreshTokenQueryRow
	err := row.Scan(&i.Ghusername, &i.Email)
	return i, err
}

const checkUserExistQuery = `-- name: CheckUserExistQuery :one
SELECT EXISTS(
    SELECT 1
    FROM user_account
    WHERE
      ghUsername = $1
  )
`

func (q *Queries) CheckUserExistQuery(ctx context.Context, db DBTX, ghusername pgtype.Text) (bool, error) {
	row := db.QueryRow(ctx, checkUserExistQuery, ghusername)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createUserAccountQuery = `-- name: CreateUserAccountQuery :one
INSERT INTO user_account (
    first_name,
    last_name,
    email,
    password
) VALUES (
    $1, $2, $3, $4
) RETURNING first_name, last_name, email
`

type CreateUserAccountQueryParams struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
	Password  string `json:"password"`
}

type CreateUserAccountQueryRow struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Email     string `json:"email"`
}

func (q *Queries) CreateUserAccountQuery(ctx context.Context, db DBTX, arg CreateUserAccountQueryParams) (CreateUserAccountQueryRow, error) {
	row := db.QueryRow(ctx, createUserAccountQuery,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Password,
	)
	var i CreateUserAccountQueryRow
	err := row.Scan(&i.FirstName, &i.LastName, &i.Email)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password 
FROM user_account 
WHERE email = $1 LIMIT 1
`

type GetUserByEmailRow struct {
	ID       int32  `json:"id"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, db DBTX, email string) (GetUserByEmailRow, error) {
	row := db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(&i.ID, &i.Email, &i.Password)
	return i, err
}

const retriveExistingUserQuery = `-- name: RetriveExistingUserQuery :one
SELECT
  email,
  ghUsername
FROM
  user_account
WHERE
  ghUsername = $1
`

type RetriveExistingUserQueryRow struct {
	Email      string      `json:"email"`
	Ghusername pgtype.Text `json:"ghusername"`
}

func (q *Queries) RetriveExistingUserQuery(ctx context.Context, db DBTX, ghusername pgtype.Text) (RetriveExistingUserQueryRow, error) {
	row := db.QueryRow(ctx, retriveExistingUserQuery, ghusername)
	var i RetriveExistingUserQueryRow
	err := row.Scan(&i.Email, &i.Ghusername)
	return i, err
}

const updateUserGithubUsername = `-- name: UpdateUserGithubUsername :exec
UPDATE user_account 
SET ghUsername = $1, updated_at = NOW() 
WHERE email = $2
`

type UpdateUserGithubUsernameParams struct {
	Ghusername pgtype.Text `json:"ghusername"`
	Email      string      `json:"email"`
}

func (q *Queries) UpdateUserGithubUsername(ctx context.Context, db DBTX, arg UpdateUserGithubUsernameParams) error {
	_, err := db.Exec(ctx, updateUserGithubUsername, arg.Ghusername, arg.Email)
	return err
}

const verifyOtpQuery = `-- name: VerifyOtpQuery :one
DELETE FROM 
  user_onboarding
WHERE
  ghUsername = $1
  AND otp = $2
  AND expiry_at > NOW()
RETURNING
  first_name, middle_name, last_name, email, ghUsername
`

type VerifyOtpQueryParams struct {
	Ghusername pgtype.Text `json:"ghusername"`
	Otp        string      `json:"otp"`
}

type VerifyOtpQueryRow struct {
	FirstName  string      `json:"first_name"`
	MiddleName pgtype.Text `json:"middle_name"`
	LastName   string      `json:"last_name"`
	Email      string      `json:"email"`
	Ghusername pgtype.Text `json:"ghusername"`
}

func (q *Queries) VerifyOtpQuery(ctx context.Context, db DBTX, arg VerifyOtpQueryParams) (VerifyOtpQueryRow, error) {
	row := db.QueryRow(ctx, verifyOtpQuery, arg.Ghusername, arg.Otp)
	var i VerifyOtpQueryRow
	err := row.Scan(
		&i.FirstName,
		&i.MiddleName,
		&i.LastName,
		&i.Email,
		&i.Ghusername,
	)
	return i, err
}
