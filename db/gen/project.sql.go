// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: project.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkIfProjectExistsQuery = `-- name: CheckIfProjectExistsQuery :one
SELECT EXISTS
  (
    SELECT 1 FROM repository
    WHERE id = $1
    LIMIT 1
)
`

func (q *Queries) CheckIfProjectExistsQuery(ctx context.Context, db DBTX, id uuid.UUID) (bool, error) {
	row := db.QueryRow(ctx, checkIfProjectExistsQuery, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const fetchAllIssuesByProjectIdQuery = `-- name: FetchAllIssuesByProjectIdQuery :many
SELECT
  i.id AS issue_id,
  i.title AS title,
  i.url AS issue_url,
  i.updated_at AS last_update,
  COALESCE(
    JSON_AGG(
      JSON_BUILD_OBJECT(
        'username', c.ghUsername,
        'claimed_on', c.claimed_on,
        'elapsing_on', c.elapsed_on
      ) ORDER BY c.claimed_on
    ) FILTER (WHERE c.id IS NOT NULL),
  '[]'::JSON
  ) AS claimants
FROM issues i
LEFT JOIN
  issue_claims AS c 
  ON c.issue_url = i.url
WHERE 
  i.resolved = false
  AND i.id = $1
GROUP BY
  i.id, 
  i.title, 
  i.url, 
  i.updated_at
ORDER BY
  i.id
`

type FetchAllIssuesByProjectIdQueryRow struct {
	IssueID    uuid.UUID        `json:"issue_id"`
	Title      string           `json:"title"`
	IssueUrl   string           `json:"issue_url"`
	LastUpdate pgtype.Timestamp `json:"last_update"`
	Claimants  interface{}      `json:"claimants"`
}

func (q *Queries) FetchAllIssuesByProjectIdQuery(ctx context.Context, db DBTX, id uuid.UUID) ([]FetchAllIssuesByProjectIdQueryRow, error) {
	rows, err := db.Query(ctx, fetchAllIssuesByProjectIdQuery, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAllIssuesByProjectIdQueryRow
	for rows.Next() {
		var i FetchAllIssuesByProjectIdQueryRow
		if err := rows.Scan(
			&i.IssueID,
			&i.Title,
			&i.IssueUrl,
			&i.LastUpdate,
			&i.Claimants,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchAllProjectsQuery = `-- name: FetchAllProjectsQuery :many
SELECT 
  id, name, description, url, maintainers, tags, is_internal
FROM 
  repository
`

type FetchAllProjectsQueryRow struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	Description string      `json:"description"`
	Url         string      `json:"url"`
	Maintainers []string    `json:"maintainers"`
	Tags        []string    `json:"tags"`
	IsInternal  pgtype.Bool `json:"is_internal"`
}

func (q *Queries) FetchAllProjectsQuery(ctx context.Context, db DBTX) ([]FetchAllProjectsQueryRow, error) {
	rows, err := db.Query(ctx, fetchAllProjectsQuery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAllProjectsQueryRow
	for rows.Next() {
		var i FetchAllProjectsQueryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Url,
			&i.Maintainers,
			&i.Tags,
			&i.IsInternal,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
